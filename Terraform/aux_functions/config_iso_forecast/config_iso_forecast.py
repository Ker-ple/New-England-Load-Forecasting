import pandas as pd
import numpy as np
import math
from datetime import datetime
import os
import itertools
import pg8000.native

"""
Example JSON input:
{
    "params": {
        "date_begin": "20220811",
        "date_end": "20230224"
    },
    "config": {
        "repeat": "True",
        "seconds_delta": "86400"
    }
}
"""

"""
Example JSON output:
{
    "records": [
        {
            'date_begin': '20220221', 
            'date_end': '20220308', 
        },
        {
            'date_begin': '20220309', 
            'date_end': '20220324', 
        },
        .
        .
        .,
        {
            'date_begin': '20230123', 
            'date_end': '20230206', 
        },
        {
            'date_begin': '20230207', 
            'date_end': '20230221', 
        } 
    ],
    "params": {
        "date_begin": "20220811",
        "date_end": "20230224"
    },
    "config": {
        "repeat": "True",
        "seconds_delta": "86400",
        "state_machine_arn": "arn:aws:states:us-east-1:485809471371:stateMachine:ISO-FORECAST"
    }
}
"""

def lambda_handler(event, context):
    print(event)
    make_tables()

    # This function creates date ranges for the iso-ne scrapers.

    params = event['params']
    config = event['config']
    config['state_machine_arn'] = os.environ.get('STATE_MACHINE_ARN')

    dates = define_yyyymmdd_date_range(params['date_begin'], params['date_end'])
    # a new lambda function is invoked every 30 days in consideration. each lambda is given equal share of dates to scrape.
    num_lambdas = math.ceil(len(dates)/30)
    # returns first and last date of each sub-list is returned to save message space and because the invoked lambda functions can recreate the date range themselves.

    payload = [
                {
                    'date_begin': datetime.strptime(x.tolist()[0], '%Y%m%d').strftime('%Y%m%d'), 
                    'date_end': datetime.strptime(x.tolist()[-1], '%Y%m%d').strftime('%Y%m%d')
                }
                for x in np.array_split(dates, num_lambdas)
            ]

    return {
        "records": payload,
        "params": params,
        "config": config
    }

def define_yyyymmdd_date_range(start, end):
    # We define a date range here because it simplifies assigning the number of lambdas.
    return [d.strftime('%Y%m%d') for d in pd.date_range(start, end, inclusive='left')]

def make_tables():
    conn = pg8000.native.Connection(
        user = os.environ.get('DB_USERNAME').encode('EUC-JP'),
        password = os.environ.get('DB_PASSWORD').encode('EUC-JP'),
        host = os.environ.get('DB_HOSTNAME'),
        database = os.environ.get('DB_NAME').encode('EUC-JP'),
        port = 5432
    ) 

    DDL = """CREATE TABLE IF NOT EXISTS "grid_forecast" (
            "forecast_id" INT NOT NULL GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
            "forecasted_for" TIMESTAMP,
            "forecasted_at" TIMESTAMP,
            "load_mw" REAL
            );"""

    conn.run(DDL)